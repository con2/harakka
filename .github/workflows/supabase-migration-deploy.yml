name: Deploy Supabase Migrations (Drift-aware)

on:
  # Run on PRs to develop so we can test safely (no deploy in PRs)
  pull_request:
    branches: [develop]
    paths:
      - 'supabase/migrations/**'
  # Auto-deploy only on merge/pushes to develop (after PR merge)
  push:
    branches: [develop]
    paths:
      - 'supabase/migrations/**'
  # Allow manual runs with toggles
  workflow_dispatch:
    inputs:
      deploy:
        description: 'Actually deploy migrations (false = dry-run/drift only)'
        required: true
        default: 'false'
        type: choice
        options: ['false','true']

concurrency:
  group: supabase-migrations-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write       # push branches / commit drift file
  pull-requests: write  # open or comment on PRs
  issues: write         # comment if needed

env:
  # Working with supabase/ folder directly
  SCHEMAS: public,auth
  # Using production secrets
  SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  PRODUCTION_PROJECT_ID: ${{ secrets.PRODUCTION_PROJECT_ID }}
  PRODUCTION_DB_PASSWORD: ${{ secrets.PRODUCTION_DB_PASSWORD }}

jobs:
  validate-and-deploy:
    name: Validate (and optionally deploy)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set production environment
        id: select
        run: |
          set -Eeuo pipefail
          echo "target=production" >> $GITHUB_OUTPUT
          echo "project_ref=${PRODUCTION_PROJECT_ID}" >> $GITHUB_OUTPUT
          echo "db_password=${PRODUCTION_DB_PASSWORD}" >> $GITHUB_OUTPUT

      - name: Verify required secrets
        run: |
          set -Eeuo pipefail
          [[ -n "${SUPABASE_ACCESS_TOKEN}" ]] || { echo "❌ SUPABASE_ACCESS_TOKEN missing"; exit 1; }
          [[ -n "${PRODUCTION_PROJECT_ID}" && -n "${PRODUCTION_DB_PASSWORD}" ]] || { echo "❌ PRODUCTION_* secrets missing"; exit 1; }
          echo "✅ Secrets OK for production"

      - name: Install Supabase CLI (official action)
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Authenticate & link project
        run: |
          set -Eeuo pipefail
          supabase login --token "$SUPABASE_ACCESS_TOKEN"
          supabase link --project-ref "${{ steps.select.outputs.project_ref }}" --password "${{ steps.select.outputs.db_password }}"

      - name: Check for migration changes in this commit range
        id: changes
        run: |
          set -Eeuo pipefail
          if [[ "${{ github.event_name }}" == "push" ]]; then
            PREV="HEAD~1"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PREV="origin/${{ github.base_ref }}"
          else
            # workflow_dispatch or other events: fall back to previous commit
            PREV="HEAD~1"
          fi
          echo "Diffing migrations between $PREV and HEAD..."
          CHANGED=$(git diff --name-only "$PREV" HEAD -- "supabase/migrations" || true)
          if [[ -z "$CHANGED" ]]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "ℹ️ No migration file changes in this run"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "changed<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGED" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "$CHANGED"
          fi

      - name: Drift check against remote (no changes applied)
        id: drift
        run: |
          set -Eeuo pipefail
          # Write drift into the migrations folder so the CLI uses the same location it would on dev machines
          TS=$(date +%Y%m%d%H%M%S)
          DRIFT_BASENAME="${TS}_drift.sql"
          DRIFT_FILE="supabase/migrations/${DRIFT_BASENAME}"
          rm -f "$DRIFT_FILE"
          # Generate diff directly into migrations, using the same schemas you diff locally
          supabase db diff --linked --schema $SCHEMAS -f "$DRIFT_BASENAME" || true
          if [[ -s "$DRIFT_FILE" ]]; then
            echo "has_drift=true" >> $GITHUB_OUTPUT
            echo "drift_file=$DRIFT_FILE" >> $GITHUB_OUTPUT
            echo "⚠️ Drift detected; file at $DRIFT_FILE"
          else
            echo "has_drift=false" >> $GITHUB_OUTPUT
            echo "✅ No schema drift detected"
          fi
        shell: bash

      - name: Show drift (first 200 lines)
        if: steps.drift.outputs.has_drift == 'true'
        run: |
          echo "--- BEGIN DRIFT PREVIEW ---"
          sed -n '1,200p' "${{ steps.drift.outputs.drift_file }}" || true
          echo "--- END DRIFT PREVIEW ---"

      - name: Create a drift PR (if any)
        if: steps.drift.outputs.has_drift == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          BRANCH="drift/$(date +%Y%m%d%H%M%S)"
          git checkout -b "$BRANCH"
          git add "${{ steps.drift.outputs.drift_file }}"
          git commit -m "chore(db): capture manual changes (drift)"
          git push -u origin "$BRANCH"
          gh pr create --title "DB Drift: capture manual changes" \
            --body "Automatic drift detection created this PR. Review and merge to reconcile schema." \
            --base develop --head "$BRANCH"

      - name: Decide whether to deploy
        id: deploy_gate
        run: |
          set -Eeuo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "ℹ️ PR context: validation only (no deploy)"
            exit 0
          fi
          if [[ "${{ steps.drift.outputs.has_drift }}" == "true" ]]; then
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "❌ Blocking deploy due to detected drift. A PR was/will be opened."
            exit 0
          fi
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "deploy=${{ inputs.deploy }}" >> $GITHUB_OUTPUT
          else
            # push to develop after merge: deploy
            echo "deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: Show summary
        run: |
          echo "Target: ${{ steps.select.outputs.target }}"
          echo "Migrations changed: ${{ steps.changes.outputs.has_changes }}"
          echo "Drift: ${{ steps.drift.outputs.has_drift }}"
          echo "Schemas: $SCHEMAS"

      - name: Deploy migrations
        if: steps.deploy_gate.outputs.deploy == 'true' && steps.changes.outputs.has_changes == 'true'
        run: |
          set -Eeuo pipefail
          cd supabase && supabase db push
          cd supabase && supabase migration list

      - name: Skip deploy (explain why)
        if: steps.deploy_gate.outputs.deploy != 'true'
        run: |
          echo "⏭️ Skipping deployment. See logs above for reason (PR context, manual dry-run, or drift)."
