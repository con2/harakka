/**
 * Supabase‑centric notification helpers
 * ------------------------------------
 * Contains a tiny wrapper around Realtime so the rest of the UI
 * can subscribe to a user‑scoped stream of `public.notifications` rows
 * without worrying about SQL filters or channel names.
 */
import { supabase } from "@/config/supabase";
import { RealtimePostgresInsertPayload } from "@supabase/supabase-js";
import { DBTables } from "@common/database.types";

/**
 * Database row as generated by `supabase gen types`.
 * We alias it here purely for convenience.
 */
export type NotificationRow = DBTables<"notifications">;

/**
 * Subscribes to **unread** notifications for a single user.
 *
 * The helper does two things:
 * 1. Immediately fetches all rows that are still `read_at IS NULL`
 *    so badges are correct after a full page reload.
 * 2. Opens a Realtime channel (`public:notifications`) and pushes every
 *    subsequent INSERT for that user into `onNew`.
 *
 * @param userId – `auth.user().id`
 * @param onNew  – callback invoked with each fresh `notifications` row
 * @returns      – `unsubscribe()` – always call this in `useEffect` cleanup
 *
 * @example
 * ```ts
 * useEffect(() => {
 *   const unsub = subscribeToNotifications(user.id, n =>
 *     setFeed(prev => [n, ...prev])
 *   );
 *   return unsub;        // <- important!
 * }, [user.id]);
 * ```
 */
export function subscribeToNotifications(
  userId: string,
  onNew: (n: NotificationRow) => void,
): () => void {
  // -------- initial unread fetch
  supabase
    .from("notifications")
    .select("*")
    .eq("user_id", userId)
    .is("read_at", null)
    .order("created_at", { ascending: false })
    .then(({ data, error }) => {
      if (error) {
        console.error("Failed to fetch initial notifications:", error);
      } else {
        data?.forEach((notification) => {
          onNew(notification);
        });
      }
    });

  // -------- live inserts via Realtime
  const channel = supabase
    .channel("user:notifications")
    .on(
      "postgres_changes",
      {
        event: "INSERT",
        schema: "public",
        table: "notifications",
        filter: `user_id=eq.${userId}`,
      },
      (payload: RealtimePostgresInsertPayload<NotificationRow>) => {
        onNew(payload.new);
      },
    )
    .subscribe();

  // -------- caller's cleanup
  return () => {
    void supabase.removeChannel(channel);
  };
}
