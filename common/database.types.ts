import type { MergeDeep } from "type-fest";
import type { Database as Base } from "@common/supabase.types";

/* ── Concrete shapes for our translations ─────────────── */
type ItemTranslations = {
  en: { item_name: string; item_type?: string; item_description: string };
  fi: { item_name: string; item_type?: string; item_description: string };
};

type TagTranslations = {
  en: { name: string };
  fi: { name: string };
};

/* ── Strongly‑typed notification metadata ────────────────────────────── */

import type { Database as SupaBase } from "@common/supabase.types";
/** Base row generated by `supabase gen types` */
type BaseNotificationRow = SupaBase["public"]["Tables"]["notifications"]["Row"];

/**
 * Map the `type` column → expected `metadata` shape.
 * Extend this map whenever you introduce a new notification key.
 */
type NotificationMetadataByType = {
  "booking.status_approved": {
    booking_id: string;
    booking_number: string;
    status: "confirmed";
    organization_id?: string; // context for provider org (admin)
  };
  "booking.status_rejected": {
    booking_id: string;
    booking_number: string;
    status: "rejected";
    organization_id?: string; // context for provider org (admin)
  };
  "user.created": {
    new_user_id: string;
    email: string;
    audience_roles?: string[]; // e.g. ["super_admin"]
    scope?: "global" | "org" | "role";
  };
  "booking.created": {
    booking_id: string;
    booking_number: string;
    status: string;
    organization_id?: string; // provider org for admin audience
  };
};

/**
 * Discriminated‑union row that keeps all
 * original columns but narrows `type` + `metadata`.
 */
type NotificationRow = {
  [K in keyof NotificationMetadataByType]: Omit<
    BaseNotificationRow,
    "type" | "metadata"
  > & {
    type: K;
    metadata: NotificationMetadataByType[K];
  };
}[keyof NotificationMetadataByType];

/* fallback for any unforeseen type
 * Ensure the discriminant `type` does NOT overlap with known keys,
 * so narrowing by `n.type === '...'` works correctly.
 */
type NotificationFallbackType = Exclude<
  SupaBase["public"]["Enums"]["notification_type"],
  keyof NotificationMetadataByType
>;
type NotificationRowFallback = Omit<BaseNotificationRow, "type" | "metadata"> & {
  type: NotificationFallbackType;
  metadata: Record<string, unknown>;
};

type StorageItemsJsonColumns = {
  translations?: ItemTranslations | null;
};

// Helps to override the `Json | null` type in the database schema
/* ── Add the shape of translations here ──────────────────────────── */
export type Database = MergeDeep<
  Base,
  {
    public: {
      Tables: {
        notifications: {
          Row: NotificationRow | NotificationRowFallback;
          Insert: NotificationRow | NotificationRowFallback;
          Update: Partial<NotificationRow> | NotificationRowFallback;
        };
        storage_items: {
          Row: StorageItemsJsonColumns;
          Insert: StorageItemsJsonColumns;
          Update: Partial<StorageItemsJsonColumns>;
        };
        tags: {
          Row: { translations: TagTranslations | null };
          Insert: { translations?: TagTranslations | null };
          Update: { translations?: TagTranslations | null };
        };
        storage_item_tags: {
          Row: {
            translations: TagTranslations | null;
          };
          Insert: {
            translations?: TagTranslations | null;
          };
          Update: {
            translations?: TagTranslations | null;
          };
        };
      };
    };
  }
>;

/* ── Helpers that mirror supabase-js generics but use *our* Database ── */
/**
 * Get the **row** shape of any public table in one line.
 *
 * ```ts
 * // Example: shape of a single row in `storage_items`
 * type StorageItem = DBTables<"storage_items">;
 *
 * // You now have full IntelliSense for every column:
 * const foo: StorageItem = {
 *   id: "123",
 *   item_type: "chair",
 *   // …
 * };
 * ```
 */
export type DBTables<N extends keyof Database["public"]["Tables"]> =
  Database["public"]["Tables"][N]["Row"];

/**
 * Get the **insert payload** type for any public table.
 * Only required columns remain mandatory; columns with defaults become optional.
 *
 * ```ts
 * // Example: payload for inserting into `user_organization_roles`
 * type CreateUserRoleDto = DBTablesInsert<"user_organization_roles">;
 *
 * // Only 3 FK columns are required—`id`, `created_at`, etc. are optional
 * const payload: CreateUserRoleDto = {
 *   user_id: "abc",
 *   organization_id: "org1",
 *   role_id: "role1",
 * };
 * ```
 */
export type DBTablesInsert<N extends keyof Database["public"]["Tables"]> =
  Database["public"]["Tables"][N]["Insert"];

/**
 * Get the **partial update** type for any public table.
 * All properties are optional so you can patch just a subset of columns.
 *
 * ```ts
 * // Example: updating a storage item's translations
 * type StorageItemPatch = DBTablesUpdate<"storage_items">;
 *
 * const patch: StorageItemPatch = {
 *   id: "123",
 *   translations: { en: { item_name: "Chair", item_type: "Furniture", item_description: "—" } }
 * };
 * ```
 */
export type DBTablesUpdate<N extends keyof Database["public"]["Tables"]> =
  Database["public"]["Tables"][N]["Update"];
